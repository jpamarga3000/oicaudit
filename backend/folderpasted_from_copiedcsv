import os
import shutil
import re

def organize_and_copy_files():
    """
    Prompts the user for source and destination folder paths,
    then copies files from source to destination.
    Files are organized into subfolders based on their base name.
    The script now intelligently extracts the primary name, handling:
    - Variations in file names like 'YACAPIN (1)', 'YACAPIN DEPOSIT'.
    - Differences between spaces and underscores (e.g., 'EL SALVADOR' vs 'EL_SALVADOR').
    - Leading numbers or words like '1 YACAPIN', 'YACAPIN 1', '1234 AD YACAPIN'.
    Existing files in the destination will be overwritten.
    """
    print("--- File Organizer and Copier ---")

    # 1. Get Source Folder Path
    while True:
        source_folder = input("Enter the path to the source folder (where files to copy are located): ").strip()
        if not os.path.isdir(source_folder):
            print(f"Error: '{source_folder}' is not a valid directory. Please try again.")
        else:
            break

    # 2. Get Destination Folder Path
    while True:
        destination_folder = input("Enter the path to the destination folder (where files will be pasted): ").strip()
        if not os.path.isdir(destination_folder):
            try:
                # Attempt to create the destination folder if it doesn't exist
                os.makedirs(destination_folder)
                print(f"Destination folder '{destination_folder}' created.")
                break
            except OSError as e:
                print(f"Error: Could not create destination folder '{destination_folder}'. {e}. Please try again.")
        else:
            break

    print(f"\nSource folder: {source_folder}")
    print(f"Destination folder: {destination_folder}\n")
    print("Starting file copying and organization...")

    copied_count = 0
    skipped_count = 0 # This count will now primarily be for directories, not skipped files due to existing
    error_count = 0

    try:
        # Iterate over all files in the source folder
        for filename in os.listdir(source_folder):
            source_file_path = os.path.join(source_folder, filename)

            # Skip directories, process only files
            if os.path.isfile(source_file_path):
                # Get the filename without its extension
                name_without_ext = os.path.splitext(filename)[0]

                # 1. Normalize spaces vs. underscores:
                # Replace all underscores with spaces
                normalized_name = name_without_ext.replace('_', ' ').strip()
                # Replace multiple spaces with a single space to ensure consistency
                normalized_name = re.sub(r'\s+', ' ', normalized_name).strip()

                # 2. Remove common suffixes and trailing numbers/words:
                # This splits the string at the first occurrence of patterns like:
                # ' (digit)', ' DEPOSIT', ' COPY', ' - ', or ' trailing_digit(s)'
                core_name_candidate = re.split(
                    r' \(|\sDEPOSIT|\sCOPY|\s-\s|\s\d+$',
                    normalized_name,
                    1
                )[0].strip()

                # 3. Further clean up leading numbers or common non-identifying words ("AD", "THE", "A")
                # Remove leading numbers and optional space (e.g., "1234 AD YACAPIN" -> "AD YACAPIN")
                final_name = re.sub(r'^\d+\s*', '', core_name_candidate).strip()
                # Remove leading "AD " if present (e.g., "AD YACAPIN" -> "YACAPIN")
                final_name = re.sub(r'^AD\s*', '', final_name).strip()
                # Ensure multi-spaces are single after all operations (redundant but safe)
                final_name = re.sub(r'\s+', ' ', final_name).strip()


                # Use the refined name as the subfolder name, with a fallback if empty
                target_subfolder_name = final_name if final_name else 'Unsorted_Files'

                # Construct the full path for the destination subfolder
                destination_subfolder_path = os.path.join(destination_folder, target_subfolder_name)

                # Create the subfolder if it doesn't exist
                if not os.path.exists(destination_subfolder_path):
                    os.makedirs(destination_subfolder_path)
                    print(f"  Created folder: '{target_subfolder_name}'")

                # Construct the full path for the destination file
                destination_file_path = os.path.join(destination_subfolder_path, filename)

                # Copy the file. shutil.copy2 will overwrite if the destination file exists.
                try:
                    # Check if file exists to give specific message or just overwrite
                    if os.path.exists(destination_file_path):
                        print(f"  Overwriting: '{filename}' in '{target_subfolder_name}/'")
                    else:
                        print(f"  Copied: '{filename}' to '{target_subfolder_name}/'")
                    shutil.copy2(source_file_path, destination_file_path)
                    copied_count += 1
                except Exception as e:
                    print(f"  Error copying '{filename}': {e}")
                    error_count += 1
            else:
                print(f"  Skipping directory: '{filename}'")
                skipped_count += 1 # Increment skipped count for directories

    except FileNotFoundError:
        print("Error: One of the specified paths was not found.")
        error_count += 1
    except PermissionError:
        print("Error: Permission denied. Please check your folder permissions.")
        error_count += 1
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
        error_count += 1

    print("\n--- Process Complete ---")
    print(f"Total files copied: {copied_count}")
    print(f"Total directories skipped: {skipped_count}") # Renamed for clarity
    print(f"Total files with errors: {error_count}")

# Call the function to start the process
if __name__ == "__main__":
    organize_and_copy_files()
