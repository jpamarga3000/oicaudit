import pandas as pd
import os
from sqlalchemy import create_engine, text
import traceback
import re
from datetime import datetime

# --- Configuration ---
SVACC_BASE_DIR = r"C:\\xampp\\htdocs\\audit_tool\\OPERATIONS\\SVACC"
LNACC_BASE_DIR = r"C:\\xampp\\htdocs\\audit_tool\\OPERATIONS\\LNACC" # NEW: LNACC Base Directory

DB_CONFIG = {
    'host': 'localhost',
    'user': 'root',
    'password': '',
    'database': 'dc_req_db', # Ensure this is the correct database
    'charset': 'utf8mb4'
}

# Define the exact expected column names for the SVACC tables from the CSV/Excel files.
# The 'ID' primary key will be auto-generated by MySQL, so it's not in this list.
EXPECTED_SVACC_COLUMNS = [
    'ACC', 'TYPE', 'GLCODE', 'CID', 'ACCNAME', 'DOPEN', 'DOLASTTRN',
    'BAL', 'INTRATE', 'MATDATE', 'CUMINTPD', 'CUMTAXW'
]

# NEW: Define the exact expected column names for the LNACC tables
EXPECTED_LNACC_COLUMNS = [
    'ACC', 'CID', 'GLCODE', 'LOANID', 'DOPEN', 'DOFIRSTI', 'DOLASTTRN',
    'BAL', 'INTRATE', 'CUMINTPD', 'MATDATE', 'PRINCIPAL', 'CUMPENPD',
    'DISBDATE', 'INTBAL', 'PENBAL'
]


def get_db_connection_sqlalchemy():
    """
    Establishes and returns a SQLAlchemy engine for database operations.
    """
    try:
        engine_url = (
            f"mysql+pymysql://{DB_CONFIG['user']}:{DB_CONFIG['password']}@"
            f"{DB_CONFIG['host']}/{DB_CONFIG['database']}?charset={DB_CONFIG['charset']}"
        )
        engine = create_engine(engine_url)
        # Test connection
        with engine.connect() as connection:
            print("Database connection (SQLAlchemy) successful.")
        return engine
    except Exception as e:
        print(f"Error creating SQLAlchemy engine: {e}")
        traceback.print_exc()
        return None

def create_svacc_table_if_not_exists(engine, table_name):
    """
    Creates a new SVACC table in MySQL with an auto-incrementing 'ID' primary key,
    and other columns aligned to EXPECTED_SVACC_COLUMNS.
    """
    # Define SQL data types for the columns.
    column_definitions = {
        'ACC': 'VARCHAR(255)', # ACC is no longer primary key
        'TYPE': 'VARCHAR(255)',
        'GLCODE': 'VARCHAR(255)',
        'CID': 'VARCHAR(255)',
        'ACCNAME': 'VARCHAR(255)',
        'DOPEN': 'DATE',
        'DOLASTTRN': 'DATE',
        'BAL': 'DECIMAL(18,2)',
        'INTRATE': 'DECIMAL(5,2)',
        'MATDATE': 'DATE',
        'CUMINTPD': 'DECIMAL(18,2)',
        'CUMTAXW': 'DECIMAL(18,2)'
    }
    
    # Start with the new auto-incrementing ID primary key
    columns_sql = ["`ID` INT AUTO_INCREMENT PRIMARY KEY"]
    
    # Add other columns from EXPECTED_SVACC_COLUMNS
    for col in EXPECTED_SVACC_COLUMNS:
        col_type = column_definitions.get(col, 'VARCHAR(255)') # Default to VARCHAR if not specified
        columns_sql.append(f"`{col}` {col_type}")
    
    # Add the 'Branch' column
    columns_sql.append("`Branch` VARCHAR(255)")

    create_table_sql = f"""
    CREATE TABLE `{table_name}` (
        {', '.join(columns_sql)}
    );
    """
    try:
        with engine.connect() as connection:
            # Explicitly drop the table if it exists to ensure a fresh schema
            connection.execute(text(f"DROP TABLE IF EXISTS `{table_name}`"))
            print(f"Dropped existing table '{table_name}' (if it existed).")
            
            connection.execute(text(create_table_sql))
            connection.commit()
        print(f"Table '{table_name}' created successfully with updated schema (ID as PK).")
        return True
    except Exception as e:
        print(f"Error creating table '{table_name}': {e}")
        traceback.print_exc()
        return False

# NEW: Function to create LNACC tables
def create_lnacc_table_if_not_exists(engine, table_name):
    """
    Creates a new LNACC table in MySQL with an auto-incrementing 'ID' primary key,
    and other columns aligned to EXPECTED_LNACC_COLUMNS.
    """
    # Define SQL data types for the columns.
    lnacc_column_definitions = {
        'ACC': 'VARCHAR(255)',
        'CID': 'VARCHAR(255)',
        'GLCODE': 'VARCHAR(255)',
        'LOANID': 'VARCHAR(255)',
        'DOPEN': 'DATE',
        'DOFIRSTI': 'DATE',
        'DOLASTTRN': 'DATE',
        'BAL': 'DECIMAL(18,2)',
        'INTRATE': 'DECIMAL(5,4)', # DECIMAL(5,4) for percentage / 100
        'CUMINTPD': 'DECIMAL(18,2)',
        'MATDATE': 'DATE',
        'PRINCIPAL': 'DECIMAL(18,2)',
        'CUMPENPD': 'DECIMAL(18,2)',
        'DISBDATE': 'DATE',
        'INTBAL': 'DECIMAL(18,2)',
        'PENBAL': 'DECIMAL(18,2)'
    }
    
    # Start with the new auto-incrementing ID primary key
    columns_sql = ["`ID` INT AUTO_INCREMENT PRIMARY KEY"]
    
    # Add other columns from EXPECTED_LNACC_COLUMNS
    for col in EXPECTED_LNACC_COLUMNS:
        col_type = lnacc_column_definitions.get(col, 'VARCHAR(255)')
        columns_sql.append(f"`{col}` {col_type}")
    
    # Add the 'Branch' column
    columns_sql.append("`Branch` VARCHAR(255)")

    create_table_sql = f"""
    CREATE TABLE `{table_name}` (
        {', '.join(columns_sql)}
    );
    """
    try:
        with engine.connect() as connection:
            connection.execute(text(f"DROP TABLE IF EXISTS `{table_name}`"))
            print(f"Dropped existing table '{table_name}' (if it existed).")
            
            connection.execute(text(create_table_sql))
            connection.commit()
        print(f"Table '{table_name}' created successfully with updated schema (ID as PK).")
        return True
    except Exception as e:
        print(f"Error creating table '{table_name}': {e}")
        traceback.print_exc()
        return False


def transfer_svacc_csv_to_mysql():
    """
    Reads SVACC CSV/Excel files from SVACC_BASE_DIR, extracts branch names,
    and uploads data to corresponding MySQL tables (svacc_branchname),
    ensuring column alignment and handling duplicate 'ACC' values.
    """
    engine = get_db_connection_sqlalchemy()
    if engine is None:
        print("Failed to get database engine. Exiting.")
        return

    if not os.path.exists(SVACC_BASE_DIR):
        print(f"SVACC_BASE_DIR not found: {SVACC_BASE_DIR}")
        return

    print(f"Scanning directory: {SVACC_BASE_DIR} for SVACC CSV/Excel files...")
    
    file_pattern = re.compile(r'^(.*?) - \d{2}-\d{2}-\d{4}\.(csv|xlsx)$', re.IGNORECASE)

    for filename in os.listdir(SVACC_BASE_DIR):
        match = file_pattern.match(filename)
        if match:
            raw_branch_name = match.group(1).strip()
            file_extension = match.group(2).lower()
            filepath = os.path.join(SVACC_BASE_DIR, filename)

            table_name_suffix = raw_branch_name.lower().replace(' ', '_')
            target_table_name = f"svacc_{table_name_suffix}"

            print(f"\nProcessing file: {filename}")
            print(f"Detected branch: '{raw_branch_name}', Target table: '{target_table_name}'")

            try:
                if file_extension == 'csv':
                    df = pd.read_csv(filepath, encoding='utf-8-sig', dtype=str, low_memory=False)
                elif file_extension == 'xlsx':
                    df = pd.read_excel(filepath, dtype=str, engine='openpyxl')
                else:
                    print(f"Skipping unsupported file type: {filename}")
                    continue

                # Standardize column names: strip whitespace and convert to uppercase
                df.columns = [col.strip().upper() for col in df.columns]

                # --- CRITICAL: Reindex DataFrame to match the exact expected columns ---
                # This ensures correct column order and handles missing/extra columns
                df = df.reindex(columns=EXPECTED_SVACC_COLUMNS, fill_value=None)
                
                # Data Cleaning and Type Conversion based on expected types
                for col in ['BAL', 'INTRATE', 'CUMINTPD', 'CUMTAXW']:
                    if col in df.columns:
                        df[col] = pd.to_numeric(df[col].astype(str).str.replace(',', ''), errors='coerce').fillna(0)

                for col in ['DOPEN', 'DOLASTTRN', 'MATDATE']:
                    if col in df.columns:
                        df[col] = pd.to_datetime(df[col], errors='coerce')
                
                # --- Handle duplicate 'ACC' values (no longer primary key, but still good to deduplicate) ---
                initial_rows = len(df)
                if 'ACC' in df.columns:
                    # Drop rows where ACC is NaN or empty, as they are likely invalid records
                    df.dropna(subset=['ACC'], inplace=True) 
                    # Drop duplicates based on 'ACC', keeping the last occurrence
                    df.drop_duplicates(subset=['ACC'], keep='last', inplace=True)
                    if len(df) < initial_rows:
                        print(f"Removed {initial_rows - len(df)} duplicate 'ACC' entries (or entries with missing ACC) from {filename}.")
                else:
                    print(f"Warning: 'ACC' column not found in {filename}. Cannot perform ACC-based deduplication.")


                # Add the 'Branch' column
                df['Branch'] = raw_branch_name

                # Create the table (or drop and recreate it) with the correct schema
                if not create_svacc_table_if_not_exists(engine, target_table_name):
                    print(f"Failed to create or verify table '{target_table_name}'. Skipping data transfer for this file.")
                    continue

                # Insert data into MySQL
                # The 'ID' column will be auto-generated by MySQL
                df.to_sql(target_table_name, con=engine, if_exists='append', index=False)
                print(f"Successfully transferred {len(df)} records from '{filename}' to '{target_table_name}'.")

            except Exception as e:
                print(f"Error processing file {filename}: {e}")
                traceback.print_exc()

    print("\nSVACC data transfer process completed.")


# NEW: Function to transfer LNACC CSV/Excel files to MySQL
def transfer_lnacc_csv_to_mysql():
    """
    Reads LNACC CSV/Excel files from LNACC_BASE_DIR, extracts branch names,
    and uploads data to corresponding MySQL tables (lnacc_branchname),
    ensuring column alignment and handling duplicate 'ACC' values.
    Divides 'INTRATE' by 100.
    """
    engine = get_db_connection_sqlalchemy()
    if engine is None:
        print("Failed to get database engine. Exiting.")
        return

    if not os.path.exists(LNACC_BASE_DIR):
        print(f"LNACC_BASE_DIR not found: {LNACC_BASE_DIR}")
        return

    print(f"Scanning directory: {LNACC_BASE_DIR} for LNACC CSV/Excel files...")
    
    file_pattern = re.compile(r'^(.*?) - \d{2}-\d{2}-\d{4}\.(csv|xlsx)$', re.IGNORECASE)

    for filename in os.listdir(LNACC_BASE_DIR):
        match = file_pattern.match(filename)
        if match:
            raw_branch_name = match.group(1).strip()
            file_extension = match.group(2).lower()
            filepath = os.path.join(LNACC_BASE_DIR, filename)

            table_name_suffix = raw_branch_name.lower().replace(' ', '_')
            target_table_name = f"lnacc_{table_name_suffix}" # Table name for LNACC

            print(f"\nProcessing file: {filename}")
            print(f"Detected branch: '{raw_branch_name}', Target table: '{target_table_name}'")

            try:
                if file_extension == 'csv':
                    df = pd.read_csv(filepath, encoding='utf-8-sig', dtype=str, low_memory=False)
                elif file_extension == 'xlsx':
                    df = pd.read_excel(filepath, dtype=str, engine='openpyxl')
                else:
                    print(f"Skipping unsupported file type: {filename}")
                    continue

                # Standardize column names: strip whitespace and convert to uppercase
                df.columns = [col.strip().upper() for col in df.columns]

                # --- CRITICAL: Reindex DataFrame to match the exact expected columns ---
                df = df.reindex(columns=EXPECTED_LNACC_COLUMNS, fill_value=None)
                
                # Data Cleaning and Type Conversion based on expected types
                for col in ['BAL', 'PRINCIPAL', 'CUMPENPD', 'INTBAL', 'PENBAL', 'CUMINTPD']:
                    if col in df.columns:
                        df[col] = pd.to_numeric(df[col].astype(str).str.replace(',', ''), errors='coerce').fillna(0)

                # Divide INTRATE by 100
                if 'INTRATE' in df.columns:
                    df['INTRATE'] = pd.to_numeric(df['INTRATE'].astype(str).str.replace(',', '').str.replace('%', ''), errors='coerce').fillna(0)
                    df['INTRATE'] = df['INTRATE'] / 100.0 # Divide by 100

                for col in ['DOPEN', 'DOFIRSTI', 'DOLASTTRN', 'MATDATE', 'DISBDATE']:
                    if col in df.columns:
                        df[col] = pd.to_datetime(df[col], errors='coerce')
                
                # --- Handle duplicate 'ACC' values (not primary key, but good for data integrity) ---
                initial_rows = len(df)
                if 'ACC' in df.columns:
                    df.dropna(subset=['ACC'], inplace=True)
                    df.drop_duplicates(subset=['ACC'], keep='last', inplace=True)
                    if len(df) < initial_rows:
                        print(f"Removed {initial_rows - len(df)} duplicate 'ACC' entries (or entries with missing ACC) from {filename}.")
                else:
                    print(f"Warning: 'ACC' column not found in {filename}. Cannot perform ACC-based deduplication.")

                # Add the 'Branch' column
                df['Branch'] = raw_branch_name

                # Create the table (or drop and recreate it) with the correct schema
                if not create_lnacc_table_if_not_exists(engine, target_table_name):
                    print(f"Failed to create or verify table '{target_table_name}'. Skipping data transfer for this file.")
                    continue

                # Insert data into MySQL
                df.to_sql(target_table_name, con=engine, if_exists='append', index=False)
                print(f"Successfully transferred {len(df)} records from '{filename}' to '{target_table_name}'.")

            except Exception as e:
                print(f"Error processing file {filename}: {e}")
                traceback.print_exc()

    print("\nLNACC data transfer process completed.")


if __name__ == '__main__':
    # Call both SVACC and LNACC transfer functions
    transfer_svacc_csv_to_mysql()
    transfer_lnacc_csv_to_mysql() # NEW: Call LNACC transfer function
